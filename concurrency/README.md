# Spring-Concurrency
- 스프링에서 발생하는 동시성 이슈에 대해서 다룬다.
- 이를 Redis를 통해 분산락을 구현하여 해결해본다.

## 요구사항
- 책과 재고는 일대일 관계로 매핑되어 있음 (하나의 도서당 1의 재고)
- 이를 바탕으로 도출할 수 있는 Core 비즈니스 로직 다음과 같다.
  - 도서 구매시 성공하면 재고가 1 감소해야함
  - 도서 구매 시 재고가 부족하면 예외를 반환해야함.
  - 재고 등록 시 성송하면 재고가 1 증가

## 분산 락(Distributed Lock) 주의사항
- Redisson을 사용하 분산락을 구현할때 유의할 점은 분산락 해제 시점과 트랜잭션 커밋시점을 일치해주어야 한다는 것입니다.
  - 스프링에서 제공하는 @Transactional은 호출되는 메서드 외부에서 프록시를 통해 처리되지만, 락 획득과 해제가 트랜잭션 내부에서 일어난다면 시점 불일치로 인해 무결성이 깨질 수 있다.
    - 만약 스레드 1과 스레드 2가 경합한다면 스레드 1의 락이 해제되고 트랜잭션 커밋이 되는 사이에 스레드 2가 락을 획득하게 되는 상황이 발생할 수 있다.
    - 데이터베이스 상으로 락이 존재하지 않기 때문에 스레드 2는 데이터를 읽어오게 되고, 스레드 1의 변경 내용은 최종적으로 유실될 수 있다. 
- 그렇기에 최종적으로 트랜잭션이 락 범위내에 포함되도록 로직을 구성하여야함 

## Synchronized 구현사항
- 다중 스레드 환경에서 공유 자원에 대한 동기화를 달성하기 위한 키워드인 synchronzied 키워드를 이용하여, 동시성 제어 테스트

## Synchronized 주의사항
- 스프링 트랜잭션 매커니즘 상 AOP 동작방식 프록시를 통해서 메서드를 직접 호출하기에 트랜잭션의 커밋 시점이 메서드 호출 후이고  synchronized 키워드를 사용하더라도 데이터베이스 커밋 이전에 다음 쓰레드가 접근이 가능하기 때문에 테스트가 실패

## Pessimistic Lock 구현사항
- 기존 JPA Repository를 이용하여 `LockType`을 별도로 지정하여 구현한다.

## Optimistic Lock 구현사항
- pessimistic lock을 구현할 때와 마찬가지로 LockType을 별도로 지정하여 구현하나, Entity에 식별자값이 될수 있는 필드값과 `@Version` 어노테이션을 통해 별도로 관리
- Optimistic Lock의 경우 Application Level에서 실행되므로 만약, Tracsaction이 동시에 값을 수정,삽입하는 경우를 대비하여 Rollback이나, Re-Try하는 기준을 지정해주어야함